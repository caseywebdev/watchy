#!/usr/bin/env node

// Handle command line options.
var optimist = require('optimist');
var argv = optimist
  .usage('Usage: $0 [-w paths,to,watch] -- command arg1 arg2...')
  .options({
    watch: {
      alias: 'w',
      type: 'string',
      desc: 'A path or comma-separated paths to watch.'
    },
    'ignore-paths': {
      alias: 'i',
      type: 'string',
      desc: 'A path or comma-separated paths to ignore.'
    },
    'ignore-basenames': {
      alias: 'I',
      type: 'string',
      desc: 'A basename regex to ignore (ie \\.css$).'
    },
    signal: {
      alias: 's',
      type: 'string',
      desc: 'Send a kill signal (SIGNIT, SIGQUIT, etc...) to the previously ' +
        'spawned process when a new one is launched.'
    },
    verbose: {
      alias: 'v',
      default: false,
      type: 'boolean',
      desc: 'Log process starts and error exits in stdout.'
    },
    growl: {
      alias: 'g',
      default: false,
      type: 'boolean',
      desc: 'Use growl notifications for process starts and error exits.'
    },
    'keep-alive': {
      alias: 'k',
      default: false,
      type: 'boolean',
      desc: 'Restart the process if it exits. Useful for servers.'
    }
  })
  .check(function () {
    if (!optimist.argv._[0]) throw new Error('Please specify a command.');
  })
  .argv;

// Require dependencies.
require('colors').setTheme({info: 'grey', error: 'red', success: 'green'});
var growl = require('growl');
var spawn = require('child_process').spawn;
var watchr = require('watchr');

var alert = function (title, message, type) {
  var name = 'watchy';
  var image = (function () {
    switch (type) {
    case 'success':
      return 'node_modules/mocha/images/ok.png';
    case 'error':
      return 'node_modules/mocha/images/error.png';
    }
  })();
  if (argv.growl) growl(message, {title: title, name: name, image: image});
  message = ('[' + name + '] ' + title.bold + ' ' + message)[type];
  if (type === 'error') return console.error(message);
  if (argv.verbose) console.log(message);
};

// Define the callback listener.
var signal = argv.signal;
var command = argv._[0];
var args = argv._.slice(1);
var title = argv._.join(' ');
var keepAlive = argv['keep-alive'];
var child;
var run = function () {
  if (child && signal) {
    if (!keepAlive) child.on('close', run);
    return child.kill(signal);
  }
  child = spawn(command, args);
  alert(title, 'Spawning...', 'info');
  child.on('close', function (code, signal) {
    if (signal) alert(title, 'Killed with signal ' + signal, 'info');
    if (code === 0) alert(title, 'Exited cleanly', 'info');
    if (code) alert(title, 'Exited with error code ' + code, 'error');
    child = null;
    if (keepAlive) run();
  });
  child.stdout.pipe(process.stdout);
  child.stderr.pipe(process.stderr);
  child.stdin.end();
};

// Run immediately.
run();

// Start watching if paths are specified.
if (argv.watch) {
  watchr.watch({
    paths: argv.watch.split(','),
    ignorePaths: argv['ignore-paths'] && argv['ignore-paths'].split(','),
    ignoreCustomPatterns: argv['ignore-basenames'] &&
      new RegExp(argv['ignore-basenames'], 'i'),
    listener: run
  });
}
