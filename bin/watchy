#!/usr/bin/env node

// Handle command line options.
var _ = require('underscore');
var Log = require('../lib/log');
var optimist = require('optimist');
var path = require('path');
var Pheonix = require('../lib/pheonix');
var chokidar = require('chokidar');

var argv = optimist
  .usage('Usage: $0 [-w paths,to,watch] -- command arg1 arg2...')
  .options({
    watch: {
      alias: 'w',
      type: 'string',
      desc: 'A path or comma-separated paths to watch.'
    },
    ignore: {
      alias: 'i',
      default: '/\\.',
      type: 'string',
      desc: 'A regex of file paths to ignore.'
    },
    'keep-alive': {
      alias: 'k',
      default: false,
      type: 'boolean',
      desc: 'Restart the process if it exits. Useful for servers.'
    },
    wait: {
      alias: 'W',
      default: 0,
      type: 'number',
      desc: 'Time (sec) to wait after sending SIGTERM to forcefully SIGKILL.'
    }
  })
  .check(function () {
    if (!optimist.argv._[0]) throw new Error('Please specify a command.');
  })
  .argv;

var log = new Log(argv, _.pick(argv, 'verbose', 'growl'));
var command = argv._[0];
var args = argv._.slice(1);
var options = _.extend({log: log}, _.pick(argv, 'wait'));
if (argv['keep-alive']) options.keepAlive = true;
var pheonix = new Pheonix(command, args, options);

// Start watching if paths are specified.
if (argv.watch) {
  var watcher = chokidar
    .watch(_.map(argv.watch.split(','), function (p) {
      return path.resolve(p);
    }), {
      ignored: new RegExp(argv.ignore),
      ignoreInitial: true,
      persistent: true
    })
    .on('all', _.bind(pheonix.spawn, pheonix));
  process.on('SIGTERM', _.bind(watcher.close, watcher));
}

process.on('SIGTERM', _.bind(pheonix.kill, pheonix, true));
